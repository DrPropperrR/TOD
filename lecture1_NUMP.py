import numpy as np # импортируем библиотку numpy

a = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8]) # записываем массив в переменную а с помощью nd.array
print(a)
print(type(a)) # выведем тип переменной а и видим, что тип данной переменной - массив numpy
print(a.size) # выводим размер массива (кол-во элементов)

# если мы работаем с одномерным массивом, как в примере выше, то мы можем вывести его форму
# с помощью метода shape
print(a.shape) # в таком виде метод shape выводит одномерный массив

# построим обычный двухмерный массив ndarray
b = np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9], [10, 11, 12, 13, 14]])
print(b)

# выведем форму массива b
print(b.shape)

# также мы можем определить кол-во измерений массивов (а и b) двумя методами
print(len(a.shape))
print(a.ndim)
print(len(b.shape))
print(b.ndim)

# создадим "не прямоугольный" вложенный список
l_non_rect = [[1,2,3], [1,2], [1,2,3,4]]
# выведем размерность данного списка по внешнему измерению
print(len(l_non_rect))
# выведем размерность массива по вложенному измерению
print([len(l) for l in l_non_rect]) # она не будет совпадать, так как данный список "не прямоугольный"
# также можем обратиться к какому-либо элементу из данного списка
print(l_non_rect[0][1])

# ndarray из такого "не прямоугольного списка" создается, но не является двумерным
# видимо он создавался ранее, ибо сейчас в 2024 я пробую и выдает ошибку, видимо уже не создается
#a_l_non_rect = np.array(l_non_rectl)
#print(a_l_non_rect)

c = np.array([1, 2, 3, 4, 5, 6, 7, 8])
print(c.size)
print(c.shape)
# c помощью функции метода reshape можно менять форму массива
c2 = c.reshape((2, 4))
print(c2)
print(c2.size)
print(c2.shape)

# снова изменим размерность нашего изначального массива с так, чтобы было 4 строки и 2 столбца
c3 = c.reshape(4, 2)
print(c3)
# теперь изменим нулевой [0] элемент в изначальном массиве с и посмотрим, что произойдет с другими массивами
c[0] = 10
print(c, c2, c3, sep='\n') # как мы в видем [0] элемент массива изменился в каждой из "новых" массивов
# новых пишу в кавычках, так как это не новые массивы, а один массив с разными загаловками

# если мы не хотим, чтобы при изменении элементов массива, сохраненного под одним заголовком менялись
# элементы массива под всеми остальными заголовками, мы должны специально копировать дынный массив
c4copy = c3.copy()
print(c4copy)
c4copy[0, 0] = 100
print(c4copy, c3, sep='\n') # обратим внимание, что имзменение в копии не привело к изменению в оригинале

# работа с типами данных numpy
print(b.dtype, a.dtype, sep='\n') # методом dtype опеределяем тип элементов массива

# при создании массива мы можем явно объявить тип данных
d1 = np.array([[1, 2], [3, 4]], dtype=np.float_)
print(d1, d1.dtype, sep='\n')

# авто оперделитель типа выберет самый простой (достаточный) тип данных для набора
d2 = np.array([[1,2], [3,4]])
print(d2, d2.dtype, sep='\n')

# даже одно значение более сложного типа потребует хранения всего массива с использованием это типа
d2 = np.array([[1,2], [3,4.0]])
print(d2, d2.dtype, sep='\n')

# мы можем узнать размер в байтах элемента (одного) того или иного типа
d2_dt = d2.dtype
print(d2_dt.itemsize)
# или так
print(d2.itemsize)

# также можем узнать размер всего массива в байтах
print(d2.nbytes)
# или так
print(d2.itemsize * d2.size)

# создание массивов с помощью функции для герерации массивов
# для начала создадим обычный список питон через функцию
print(list(range(10)))
# теперь создадим аналогичный данному списку массив с помощью numpy
ar1 = np.arange(10) # тут мо жет быть прописан страрт, стоп ишаг данного массива
print(ar1)

ar1 = np.arange(0, 10, 1)
print(ar1)

# также мы можем сгенерировать массив типа float
ar2 = np.arange(-1, 1, 0.1, dtype=np.float64)
print(ar2, ar2.dtype, sep='\n')

# если необходимо задать последовательность с каким-то равным шагом, включая границы
# то для этого в numpy есть удобная функция linspace(start, stop, num, .. )
print(np.linspace(0,10, 25))

# geomspace генерирует геометрическую последовательность значений из интервала включая границы
print(np.geomspace(1, 256, 9))

# модуль random позволяет генерировать специальные числа, в этом модуле ест функция rand
print(np.random.rand(5, 5)) # аргументы функции ренд (кол-во строк массива, кол-во столбцов)

# метод diag формирует диагональную матрицу
print(np.diag([1, 2, 3]))

# матрица из нулей
print(np.zeros((3,3)))

# матрица из нулей типа int
print(np.zeros((3,3), dtype=np.int_))

# сохранение ndarray в файл и загрузка из файла

print(a)
np.save('a_ndarr.npy', a) # сохранили массив а в файл с названием a_ndarr.npy
a_ld = np.load('a_ndarr.npy') # загрузили в файл a_ld данные с a_ndarr.npy
print(a_ld) # убеждаемся, что массивы a и a_ld идентичны
print(a == a_ld) # проверяем идентичность

# теперь сохраним и загрузим несколько массивов в npz
print(a) # исходный массив 1
print(b) # исходный массив 2
np.savez('ab_ndarr.npz', a=a, b=b) # загружаем оба эти массива в файл ab_ndarr.npz
# внимание - тут формат файла .npz так как загружаем в файл несколько массивов, для одного был бы .npy

npzfile = np.load('ab_ndarr.npz') # в переменную npzfile загружаем архив ab_ndarr.npz с 2мя массивами
print(npzfile) # на строке вывода мы видим, что данный файл имеет расширение npz и содержит файлы a, b

print(npzfile['b']) # так мы можем увидеть содержание массива b из файла npzfile
print(npzfile['a']) # аналогично смотрим массив a

# если мы не задаем название массивов внутри архива, то оно будет поставлено автоматически
np.savez('xx_ndarr.npz', a, b) # не даем имена массивами a и b
npzfile2 = np.load('xx_ndarr.npz') # загружаем данный файл в переменную npzfile2
print(npzfile2) # при выводе видем, что имена этим двум массивам были даны автоматически arr_0, arr_1

# savetxt - сохраняет файл в формтете txt, а loadtxt загружает файл этого формата
np.savetxt('b_s1.txt', b, delimiter=',') # сохраняем файл и задаем разделение в виде запятой
# просмотрим этот файл
with open('b_s1.txt', 'r') as file:
    for line in file:
        print(line)
print(np.loadtxt('b_s1.txt', delimiter=',')) # выводим данный файл другим методом

# также можно при сохранении файла указать разрядность (кол-во цифор после запятой)
np.savetxt('b_s2.txt', b, fmt='%1.4e') # формат указываем 4 цифры после запятой
# выводим данный массив
with open('b_s2.txt', 'r') as file:
    for line in file:
        print(line)
# загружаем из файла
print(np.loadtxt('b_s2.txt'))








































